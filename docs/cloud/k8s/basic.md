---
layout: default
title: 쿠버네티스 기초잡기
parent: Kubernetes
grand_parent: Cloud
nav_order: 1
---

# **쿠버네티스의 아키텍쳐 및 동작 원리**

하나의 쿠버네티스 클러스터상에 존재하는 서버들은 기본적으로 마스터와 노드라는 두 가지 역할을 할당받는다. 마스터 역할을 할당받은 서버는 쿠버네티스 중앙의 관리 센터로서, 컴포넌트들을 실행하게 된다.

쿠버네티스는 고가용성을 실현하기 위해 둘 이상의 마스터 서버를 가질 수 있으며, 마스터 서버는 쿠버네티스 API 서버와 키/값 저장소, 그리고 스케줄러 및 컨트롤러의 실행을 담당한다.

이러한 컴포넌트는 외부 환경과 상호작용하고, 클러스터 혹은 사용자 요청의 변화를 ㅣ반으로 결정을 내리는 쿠버네티스의 두뇌를 형성한다.

클러스터의 다른 서버에는 노드로서의 역할이 할당되고 컨테이너를 사용해 워크로드를 실행한다. 노드 서버는 마스터로부터 정의된 워크로드를 수신하고, 그에 따라 컨테이너를 작성하거나 갱신 또는 삭제하는 역할을 수행할 것이다. 또한 노드는 컨테이너에 필요한 네트워크와 스토리지를 형성하고, 노드 간에 래픽을 전송한다.

마스터와 노드 컴포넌트들을 포함하는 쿠버네티스는 쿠버네티스 API를 통해 제공된 애플리케이션의 원하는 상태를 기반으로 작동한다. 그 예로서, JSON 또는 YAML을 사용한 선언적인 워크로드 정의를 마스터 서버의 쿠버네티스 API에 전송할 수 있다. 마스터 컴포넌트들은 필요한 스토리지와 네트워크, 컴퓨팅 리소스 등의 정의들을 좀 더 다양하게 적용할 수 있도록 지원하고 이 정의들은 실행을 위해 노드로 전송된다.

노드 인스턴스는 컨테이너화된 애플리케이션을 실행하고, 상태를 지속적으로 점검하는 동작을 통해 정의된 계획을 실행한다.

결론적으로, 쿠버네티스 클러스터는 실제 상태를 변경하고 테스트하는 동작을 통해 JSON이나 YAML에 정의된 상태로의 변경을 시도한다.

## 마스터 컴포넌트

컨트롤 플레인(control plane)으로도 불리는 이 영역은 API 운영부터 인증, 스케줄 및 네트워킹 등의 기능을 제공하는 서비스들의 집합을 뜻한다. 이러한 컴포넌트들은 단일 서버, 혹은 여러 서버에 분산시켜 설치할 수 있다. 컨트롤 플레인 컴포넌트들과 그들의 상호작용을 알아보자.

### etcd

etcd는 쿠버네티스 데이터의 저장소로서 모든 구성 및 런타임 정보, 그리고 상태가 저장된다. 실제 상태와 희망하는 리소스의 상태 정보는 마스터 컴포넌트 중에서 유일한 스테이트풀 컴포넌트인 etcd에 저장된다. 쿠버네티스를 신뢰할 수 있게 만드는 중요한 컴포넌트 중 하나이며, 다수의 마스터 서버에 설치될 수 있고 쿠버네티스 클러스터의 내부까지 접근할 수 있다.

### kube-apiserver

kube-apiserver는 사용자와의 상호작용과 상태 정보의 교환을 위한 쿠버네티스 클러스터의 중앙 관리형 인터페이스다. REST API 서버로서 데이터를 보내고 받을 수 있다. 모든 워크로드 정의가 이 API 서버로 전송되고, etcd의 데이터 저장을 처리한다. 쿠버네티스는 API 동작에 기반한 플랫폼이므로, kube-apiserver는 컨트롤 플레인에서 가장 중요한 컴포넌트라고 할 수 있다.

### kube-controller-manager

kube-controller-manager는 리소스의 수명주기를 관리하기 위한 쿠버네티스의 일반적인 패턴이다. 변경사항이 발생하면 컨트롤러가 새로운 정보를 찾아낸다. 이 후 원하는 상태로 변경하기 위해 필요한 사항을 구현할 것이다. 예를 들면 사용자에 의해 애플리케이션이 확장됐을 때 데이터는 kube-apiserver로 전송되고 etcd에 저장된다. 해당 리소스의 컨트롤러 매니저는 추가 인스턴스들을 생성한다. kube-controller-manager는 쿠버네티스의 리소드들을 관리하는 컨트롤러의 집합으로 구성된다.

### kube-scheduler

kube-scheduler는 용량과 요구사항, 인프라 환경 등을 고려해 워크로드 컨테이너들을 노드에 할당한다. 할당되지 않은 워크로드들을 조사하고, 이를 할당할 적절한 노드들을 찾는 동작으로 반복적으로 수행할 것이다.

### cloud-controller-manager

쿠버네티스는 필수 인터페이스를 구현한 모든 클라우드 제공자에 설치할 수 있도록 설계되었다. AWS, 구글 클라우드, 애저, 알리바바 클라우드, 또는 온프레미스상의 오픈스택 환경에서 쿠버네티스를 실행할 수 있다. cloud-controller-manager는 쿠버네티스의 리소스들을 클라우드 제공업체의 환경에 연결하기 위한 브리지 기능의 묶음이라고 할 수 있다. 예로서 이 컨트롤러 매니저는 클라우드 환경을 기반으로 스토리지 및 네트워크 요구사항을 관리한다.

## 노드 컴포넌트

노트 컴포넌트는 쿠버네티스에서 워크로드를 실행하는 역할을 담당한다. 따라서 이들은 노드에 할당된 워크로드의 컨테이너, 네트워킹 및 스토리지 작업을 관리해야 한다. 노드 컴포넌트의 소개와 함께 컨트롤 플레인과 상호작용을 알아보자.

### 컨테이너 런타임

컨테이너 런타임은 노드 서버에서 워크로드를 컨테이너로 실행하기 위해 필요하다. 이는 컨테이너 런타임 인터페이스(CRI), 도커, rkt, runc와 같은 쿠버네티스 환경에서 지원하는 컨테이너 런타임을 통해 구현될 것이다. 주요 기능은 정의된 상태에 따라 쿠버네티스 상에서 컨테이너를 시작하고, 삭제하거나 상태를 확인하는 것이다.

### kubelet

kubelet은 컨트롤 플레인에서 정보를 수집하고 노드의 리소스를 관리하는 서버에서 실행되는 기본 서비스다. kubelet은 컨트롤 플레인과 통신해 정의된 상태 정보를 얻고, 컨테이너 런타임에 커맨드를 보내 현재 상태를 정의된 상태로 변환할 것이다.

### kube-proxy

kube-proxy늩 노드 서버에서 네트워크 영역을 담당하는 서비스다. 컨테이너와 호스트 시스템은 네트워크 측면에서 격리돼 있기 때문에 요청을 컨테이너로 전달하고 외부로부터 접근할 수 있도록 돕는 서비스가 필요한데, kube-proxy가 이 부분을 담당한다.

## 쿠버네티스 기본 리소스

쿠버네티스는 확장 가능하고 강건한 클라우드 네이티브 애플리케이션의 수명주기 관리를 제공하기 위해 강력한 추상화를 제공한다. 마스터와 노드 컴포넌트는 지속적인 동작을 통해 쿠버네티스 API와 클라이언트 도구의 사용자에 의해 정의된 워크로드의 상태를 유지할 수 있게 한다.

### 파드(Pod)

파드는 쿠버네티스 연산 객체의 빌딩 블록이다. 파드는 긴밀하게 결합되어 하나의 애플리케이션으로 취급되는 컨테이너들로 이뤄져 있다. 동일한 파드에 존재하는 컨테이너들은 볼륨과 네트워크 인터페이스를 공유하기 때문에 항상 동일한 노드에서 예약된다. 따라서 파드는 함께 작동하고 함께 확장 및 축소하는 등 수명주기를 공유하는 캡슐화된 컨테이너의 집합이라고 할 수 있다.

### 레플리카셋(replication set)

레플리카셋은 클러스터에서 실행 중인 복제본 파드의 집합을 유지 관리하는 쿠버네티스 리소스다. 쿠버네티스는 고가용성을 실현하고 지원할 수 있도록 설계됐다. 따라서 레플리카셋에 정의된 인스턴스와 동일한 파드 인스턴스가 클러스터에서 실행되야 한다. 파드와 마찬가지로 레플리카셋은 디플로이먼트와 같은 수명주기 관리 리소스의 빌딩 블록이다. 다른 상위 수준의 리소스와 함께 리소스의 확대, 축소, 혹은 새 버전의 애플리케이션을 배포하는데 사용된다. 레플리카셋의 정의는 파드의 사양을 캡슐화하고 있기 때문에 파드 정의와 유사하다. replicas 항목은 클러스터에서 실행해야 하는 원하는 파드 수를 나타내며, matchLabels 항목은 복제해야 할 파드와 일치하는 레이블의 집합을 정의한다.(쿠버네티스의 레이블은 그룹화를 위해 쿠버네티스 리소스에 부착된 시멘특 태그이며 컨트롤러는 이를 사용해 리소스 그룹을 대상으로 지정하거나 관리한다.)

### 디프롤이먼트(deployment)

디플로이먼트는 컨테이너 애플리케이션을 대규모로 조금 더 쉽게 관리할 수 있도록 하는 가장 강력한 쿠버네티스 리소스 중 하나이다. 사양은 파드 정의가 캡슐화되어있는 레플리카셋과 유사하다. 레플리카셋의 정의와 비슷해 보이지만, 디플로이먼트 리소스의 힘은 디플로이먼트 컨트롤러의 기능해서 비롯된다. 디플로이먼트를 생성하거나 사양에서 필드를 변경함으로써 수명 주기를 관리할 수 있다.

- 새 애플리케이션 롤아웃\
  디플로이먼트가 쿠버네티스 API로 전송되면, 레플리카셋이 정의되고 애플리케이션이 클러스터로 배포된다.
- 실행 중인 애플리케이션에 대한 업데이트 롤아웃\
  디플로이먼트 사양을 변경하면, 이전 버전의 레플리카셋을 삭제하고 새 레플리카셋을 생성해 이러한 변경사항이 전파된다. 이 새로운 버전의 롤아웃은 전체의 %로 제어되고 관리되기 때문에, 다른 환경 변수를 파드 사양에 추가할 때 다운타임이 발생하지 않는다.
- 이전 버전으로 롤백
  새로운 릴리스를 롤아웃하는 동안 문제가 발생하더라도, 디플로이먼트 컨트롤러는 기록을 저장하고 있으므로 언제든지 변경 내용을 롤백할 수 있다.
- 실행 중인 애플리케이션을 확장/축소
  수동으로 확장 혹은 축소할 복제본의 수를 변경할 수 있다.

### 스테이트풀셋(stateful set)

쿠버네티스는 스테이트풀셋 덕분에 상태가 저장되지 않는 임시 애플리케이션과 스테이트풀 애플리케이션에 모두 동일한 수준의 확장성과 견고성을 제공할 수 있다. 스테이트풀셋은 영구 볼륨을 사용해 데이터베이스와 같은 데이터 지향 애플리케이션의 높은 수준의 요구사항을 충족시킨다. 스테이트풀셋의 정의는 디플로이먼트와 유사하며 영구 볼륨을 생성하는 볼륨 클레임(volume claim) 부분을 포함한다.
