---
layout: default
title: 파드의 생명주기에 따른 쿠버네티스 구성 요소 살펴보기
parent: Kubernetes
grand_parent: Cloud
nav_order: 3
---

# **파드의 생명주기에 따른 쿠버네티스 구성 요소 살펴보기**

{: .bg-purple-000}

---

1. kubectl을 통해 API 서버에 파드 생성을 요청한다.
2. (업데이트가 있을 때마다 매번) API 서버에 전달된 내용이 있으면 API 서버는 etcd에 전달된 내용을 모두 기록해 클러스터의 상태 값을 최신으로 유지한다.\
   따라서 각 요소가 상태를 업데이트할 때마다 모두 API 서버를 통해 etcd에 기록된다.
3. API 서버에 파드 생성이 요청된 것을 컨트롤러 매니저가 인지하면 컨트롤러 매니저는 파드를 생성하고, 이 상태를 API 서버에 전달한다.\
   아직 어떤 워커 노드에 파드를 적용할지는 적용하지 않은 상태로 파드만 생성된다.
4. API 서버에 파드가 생성됐다는 정보를 스케줄러가 인지한다. 스케줄러는 생성된 파드를 어떤 워커 노드에 적용할지 고건을 고려해 결정하고 해당 워커 노드에 파드를 띄우도록 요청한다.
5. API 서버에 전달된 정보대로 지정한 워커 노드에 파드가 속해 있는지 스케줄러가 kubelet으로 확인한다.
6. kubelet에서 컨테이너 런타임으로 파드 생성을 요청한다.
7. 파드가 생성된다.
8. 파드가 사용 가능한 상태가 된다.

{: .note}
API 서버는 감시만 하는 걸까?

쿠버네티스는 작업을 순서대로 진행하는 워크플로우를 따르는 것이 아니라 선언적인 시스템 구조를 가지고 있다.\
즉, 각 요소가 추구하는 상태를 선언하면 현재 상태와 맞는지 점검하고 그것에 맞추려고 노력하는 구조로 되어있다는 뜻이다.

따라서 추구하는 상태를 API 서버에 선언하면 다른 요소들이 API 서버에 와서 현재 상태와 비교하고 그에 맞게 상태를 변경하려고 한다.\
여기서 API는 현재 상태 값을 가지고 있는데, 이것을 보존해야 해서 etcd가 필요하다.\
API 서버와 etcd는 거의 한 몸처럼 움직이도록 설계되었다.

다만, 워커 노드는 워크플로우 구조애 따라 설계되었다.\
쿠버네티스가 kubelet과 컨테이너 런타임을 통해 파드를 새로 생성하고 제거해야하는 구조여서 선언적인 방식으로 구조화하기에는 어려움이 있기 때문이다.\
또한 명령이 절차적으로 전달되는 방식은 시스템의 성능을 높이는데 효율적이다.

하지만 마스터 노드는 이미 생성된 파드들을 유기적으로 연결하므로 쿠버네티스를 안정적으로 유지하려면 선언적인 시스템이 더 낫다.
